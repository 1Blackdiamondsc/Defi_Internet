"use strict";const Hoek=require("hoek"),Language=require("./language"),internals={stringify:function(e,t){const n=typeof e;if(null===e)return"null";if("string"===n)return e;if(e instanceof exports.Err||"function"===n)return e.toString();if("object"===n){if(Array.isArray(e)){let n="";for(let r=0;r<e.length;++r)n=n+(n.length?", ":"")+internals.stringify(e[r],t);return t?"["+n+"]":n}return e.toString()}return JSON.stringify(e)}};exports.Err=class{constructor(e,t,n,r,s){this.isJoi=!0,this.type=e,this.context=t||{},this.context.key=n.key,this.path=n.path,this.options=r,this.flags=s}toString(){const e=this.options.language;this.flags.label?this.context.key=this.flags.label:""!==this.context.key&&null!==this.context.key||(this.context.key=e.root||Language.errors.root);let t=Hoek.reach(e,this.type)||Hoek.reach(Language.errors,this.type);const n=/\{\{\!?key\}\}/.test(t),r=t.length>2&&"!"===t[0]&&"!"===t[1];r&&(t=t.slice(2)),n||r||(t=(Hoek.reach(e,"key")||Hoek.reach(Language.errors,"key"))+t);let s=Hoek.reach(e,"messages.wrapArrays");return"boolean"!=typeof s&&(s=Language.errors.messages.wrapArrays),t.replace(/\{\{(\!?)([^}]+)\}\}/g,(e,t,n)=>{const r=Hoek.reach(this.context,n),i=internals.stringify(r,s);return t?Hoek.escapeHtml(i):i})}},exports.create=function(e,t,n,r,s){return new exports.Err(e,t,n,r,s)},exports.process=function(e,t){if(!e||!e.length)return null;let n="";const r=[],s=function(e,t){for(let i=0;i<e.length;++i){const o=e[i];if(o.flags.error)return o.flags.error;let a;if(void 0===t&&(a=o.toString(),n=n+(n?". ":"")+a),o.context.reason&&o.context.reason.length){const e=s(o.context.reason,o.path);if(e)return e}else r.push({message:a||o.toString(),path:internals.getPath(o),type:o.type,context:o.context})}},i=s(e);if(i)return i;const o=new Error(n);return o.isJoi=!0,o.name="ValidationError",o.details=r,o._object=t,o.annotate=internals.annotate,o},internals.getPath=function(e){return e.path||e.context.key},internals.safeStringify=function(e,t){return JSON.stringify(e,internals.serializer(),t)},internals.serializer=function(){const e=[],t=[];return function(n,r){if(t.length>0){const s=t.indexOf(this);~s?(t.length=s+1,e.length=s+1,e[s]=n):(t.push(this),e.push(n)),~t.indexOf(r)&&(r=((n,r)=>t[0]===r?"[Circular ~]":"[Circular ~."+e.slice(0,t.indexOf(r)).join(".")+"]").call(this,n,r))}else t.push(r);if(Array.isArray(r)&&r.placeholders){const e=r.placeholders,t=[];for(let n=0;n<r.length;++n)e[n]&&t.push(e[n]),t.push(r[n]);r=t}return r===1/0||r===-1/0||Number.isNaN(r)||"function"==typeof r||"symbol"==typeof r?"["+r.toString()+"]":r}},internals.annotate=function(e){const t=e?"":"[31m",n=e?"":"[41m",r=e?"":"[0m";if("object"!=typeof this._object)return this.details[0].message;const s=Hoek.clone(this._object||{}),i={};for(let e=this.details.length-1;e>=0;--e){const t=e+1,n=this.details[e],r=n.path.split(".");let o=s;for(let e=0;e<r.length&&o;++e){const s=r[e];if(e+1<r.length)o=o[s];else{const e=o[s];if(Array.isArray(o)){const e=`_$idx$_${t}_$end$_`;o.placeholders||(o.placeholders={}),o.placeholders[s]?o.placeholders[s]=o.placeholders[s].replace("_$end$_",`, ${t}_$end$_`):o.placeholders[s]=e}else if(void 0!==e){delete o[s];const r=`${s}_$key$_${t}_$end$_`;o[r]=e,i[n.path]=r}else if(i[n.path]){const e=i[n.path],r=e.replace("_$end$_",`, ${t}_$end$_`);o[r]=o[e],i[n.path]=r,delete o[e]}else o[`_$miss$_${s}|${t}_$end$_`]="__missing__"}}}const o=/_\$key\$_([, \d]+)_\$end\$_\"/g,a=/\"_\$miss\$_([^\|]+)\|(\d+)_\$end\$_\"\: \"__missing__\"/g,l=/\s*\"_\$idx\$_([, \d]+)_\$end\$_\",?\n(.*)/g,c=/"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)\]"/g;let h=internals.safeStringify(s,2).replace(o,(e,n)=>`" ${t}[${n}]${r}`).replace(a,(e,s,i)=>`${n}"${s}"${r}${t} [${i}]: -- missing --${r}`).replace(l,(e,n,s)=>`\n${s} ${t}[${n}]${r}`).replace(c,(e,t)=>t);h=`${h}\n${t}`;for(let e=0;e<this.details.length;++e){h=`${h}\n[${e+1}] ${this.details[e].message}`}return h+=r};