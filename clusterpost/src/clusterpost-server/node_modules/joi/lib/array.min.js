"use strict";const Any=require("./any"),Cast=require("./cast"),Hoek=require("hoek"),internals={fastSplice:function(e,r){let t=r;for(;t<e.length;)e[t++]=e[t];--e.length}};internals.Array=class extends Any{constructor(){super(),this._type="array",this._inner.items=[],this._inner.ordereds=[],this._inner.inclusions=[],this._inner.exclusions=[],this._inner.requireds=[],this._flags.sparse=!1}_base(e,r,t){const s={value:e};"string"==typeof e&&t.convert&&internals.safeParse(e,s);let n=Array.isArray(s.value);const i=n;if(t.convert&&this._flags.single&&!n&&(s.value=[s.value],n=!0),!n)return s.errors=this.createError("array.base",null,r,t),s;if((this._inner.inclusions.length||this._inner.exclusions.length||this._inner.requireds.length||this._inner.ordereds.length||!this._flags.sparse)&&(i&&(s.value=s.value.slice(0)),s.errors=this._checkItems.call(this,s.value,i,r,t),s.errors&&i&&t.convert&&this._flags.single)){const e=s.errors;s.value=[s.value],s.errors=this._checkItems.call(this,s.value,i,r,t),s.errors&&(s.errors=e,s.value=s.value[0])}return s}_checkItems(e,r,t,s){const n=[];let i;const a=this._inner.requireds.slice(),l=this._inner.ordereds.slice(),o=this._inner.inclusions.concat(a);let h=e.length;for(let u=0;u<h;++u){i=!1;const c=e[u];let p=!1;const f={key:r?u:t.key,path:r?(t.path?t.path+".":"")+u:t.path,parent:t.parent,reference:t.reference};let y;if(!this._flags.sparse&&void 0===c){if(n.push(this.createError("array.sparse",null,{key:t.key,path:f.path,pos:u},s)),s.abortEarly)return n;continue}for(let e=0;e<this._inner.exclusions.length;++e)if(!(y=this._inner.exclusions[e]._validate(c,f,{})).errors){if(n.push(this.createError(r?"array.excludes":"array.excludesSingle",{pos:u,value:c},{key:t.key,path:f.path},s)),i=!0,s.abortEarly)return n;break}if(i)continue;if(this._inner.ordereds.length){if(l.length>0){const r=l.shift();if((y=r._validate(c,f,s)).errors){if(n.push(this.createError("array.ordered",{pos:u,reason:y.errors,value:c},{key:t.key,path:f.path},s)),s.abortEarly)return n}else if(r._flags.strip)internals.fastSplice(e,u),--u,--h;else{if(!this._flags.sparse&&void 0===y.value){if(n.push(this.createError("array.sparse",null,{key:t.key,path:f.path,pos:u},s)),s.abortEarly)return n;continue}e[u]=y.value}continue}if(!this._inner.items.length){if(n.push(this.createError("array.orderedLength",{pos:u,limit:this._inner.ordereds.length},{key:t.key,path:f.path},s)),s.abortEarly)return n;continue}}const d=[];let g=a.length;for(let r=0;r<g;++r)if(!(y=d[r]=a[r]._validate(c,f,s)).errors){if(e[u]=y.value,p=!0,internals.fastSplice(a,r),--r,--g,!this._flags.sparse&&void 0===y.value&&(n.push(this.createError("array.sparse",null,{key:t.key,path:f.path,pos:u},s)),s.abortEarly))return n;break}if(p)continue;const _=!!s.stripUnknown&&(!0===s.stripUnknown||!!s.stripUnknown.arrays);g=o.length;for(let l=0;l<g;++l){const k=o[l],v=a.indexOf(k);if(-1!==v)y=d[v];else if(!(y=k._validate(c,f,s)).errors){k._flags.strip?(internals.fastSplice(e,u),--u,--h):this._flags.sparse||void 0!==y.value?e[u]=y.value:(n.push(this.createError("array.sparse",null,{key:t.key,path:f.path,pos:u},s)),i=!0),p=!0;break}if(1===g){if(_){internals.fastSplice(e,u),--u,--h,p=!0;break}if(n.push(this.createError(r?"array.includesOne":"array.includesOneSingle",{pos:u,reason:y.errors,value:c},{key:t.key,path:f.path},s)),i=!0,s.abortEarly)return n;break}}if(!i&&(this._inner.inclusions.length&&!p)){if(_){internals.fastSplice(e,u),--u,--h;continue}if(n.push(this.createError(r?"array.includes":"array.includesSingle",{pos:u,value:c},{key:t.key,path:f.path},s)),s.abortEarly)return n}}return a.length&&this._fillMissedErrors.call(this,n,a,t,s),l.length&&this._fillOrderedErrors.call(this,n,l,t,s),n.length?n:null}describe(){const e=Any.prototype.describe.call(this);if(this._inner.ordereds.length){e.orderedItems=[];for(let r=0;r<this._inner.ordereds.length;++r)e.orderedItems.push(this._inner.ordereds[r].describe())}if(this._inner.items.length){e.items=[];for(let r=0;r<this._inner.items.length;++r)e.items.push(this._inner.items[r].describe())}return e}items(){const e=this.clone();return Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((r,t)=>{try{r=Cast.schema(r)}catch(e){throw e.hasOwnProperty("path")?e.path=t+"."+e.path:e.path=t,e.message=e.message+"("+e.path+")",e}e._inner.items.push(r),"required"===r._flags.presence?e._inner.requireds.push(r):"forbidden"===r._flags.presence?e._inner.exclusions.push(r.optional()):e._inner.inclusions.push(r)}),e}ordered(){const e=this.clone();return Hoek.flatten(Array.prototype.slice.call(arguments)).forEach((r,t)=>{try{r=Cast.schema(r)}catch(e){throw e.hasOwnProperty("path")?e.path=t+"."+e.path:e.path=t,e.message=e.message+"("+e.path+")",e}e._inner.ordereds.push(r)}),e}min(e){return Hoek.assert(Hoek.isInteger(e)&&e>=0,"limit must be a positive integer"),this._test("min",e,function(r,t,s){return r.length>=e?r:this.createError("array.min",{limit:e,value:r},t,s)})}max(e){return Hoek.assert(Hoek.isInteger(e)&&e>=0,"limit must be a positive integer"),this._test("max",e,function(r,t,s){return r.length<=e?r:this.createError("array.max",{limit:e,value:r},t,s)})}length(e){return Hoek.assert(Hoek.isInteger(e)&&e>=0,"limit must be a positive integer"),this._test("length",e,function(r,t,s){return r.length===e?r:this.createError("array.length",{limit:e,value:r},t,s)})}unique(e){const r=!!e;return e=e||Hoek.deepEqual,Hoek.assert("function"==typeof e,"comparator must be a function"),this._test("unique",void 0,function(t,s,n){const i={string:{},number:{},undefined:{},boolean:{},object:[],function:[],custom:[]};for(let a=0;a<t.length;++a){const l=t[a],o=typeof l,h=r?i.custom:i[o];if(h)if(Array.isArray(h)){for(let r=0;r<h.length;++r)if(e(h[r],l))return this.createError("array.unique",{pos:a,value:l},s,n);h.push(l)}else{if(h[l])return this.createError("array.unique",{pos:a,value:l},s,n);h[l]=!0}}return t})}sparse(e){const r=this.clone();return r._flags.sparse=void 0===e||!!e,r}single(e){const r=this.clone();return r._flags.single=void 0===e||!!e,r}_fillMissedErrors(e,r,t,s){const n=[];let i=0;for(let e=0;e<r.length;++e){const t=r[e]._getLabel();t?n.push(t):++i}n.length?i?e.push(this.createError("array.includesRequiredBoth",{knownMisses:n,unknownMisses:i},{key:t.key,path:t.path},s)):e.push(this.createError("array.includesRequiredKnowns",{knownMisses:n},{key:t.key,path:t.path},s)):e.push(this.createError("array.includesRequiredUnknowns",{unknownMisses:i},{key:t.key,path:t.path},s))}_fillOrderedErrors(e,r,t,s){const n=[];for(let e=0;e<r.length;++e){"required"===Hoek.reach(r[e],"_flags.presence")&&n.push(r[e])}n.length&&this._fillMissedErrors.call(this,e,n,t,s)}},internals.safeParse=function(e,r){try{const t=JSON.parse(e);Array.isArray(t)&&(r.value=t)}catch(e){}},module.exports=new internals.Array;