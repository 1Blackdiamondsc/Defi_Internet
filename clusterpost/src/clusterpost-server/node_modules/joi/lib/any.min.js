"use strict";const Hoek=require("hoek"),Ref=require("./ref"),Errors=require("./errors");let Alternatives=null,Cast=null;const internals={defaults:{abortEarly:!0,convert:!0,allowUnknown:!1,skipFunctions:!1,stripUnknown:!1,language:{},presence:"optional",strip:!1,noDefaults:!1}};module.exports=internals.Any=class{constructor(){Cast=Cast||require("./cast"),this.isJoi=!0,this._type="any",this._settings=null,this._valids=new internals.Set,this._invalids=new internals.Set,this._tests=[],this._refs=[],this._flags={},this._description=null,this._unit=null,this._notes=[],this._tags=[],this._examples=[],this._meta=[],this._inner={}}createError(t,e,s,n){return Errors.create(t,e,s,n,this._flags)}checkOptions(t){const e=require("./schemas").options.validate(t);if(e.error)throw new Error(e.error.details[0].message)}clone(){const t=Object.create(Object.getPrototypeOf(this));t.isJoi=!0,t._type=this._type,t._settings=internals.concatSettings(this._settings),t._valids=Hoek.clone(this._valids),t._invalids=Hoek.clone(this._invalids),t._tests=this._tests.slice(),t._refs=this._refs.slice(),t._flags=Hoek.clone(this._flags),t._description=this._description,t._unit=this._unit,t._notes=this._notes.slice(),t._tags=this._tags.slice(),t._examples=this._examples.slice(),t._meta=this._meta.slice(),t._inner={};const e=Object.keys(this._inner);for(let s=0;s<e.length;++s){const n=e[s];t._inner[n]=this._inner[n]?this._inner[n].slice():null}return t}concat(t){Hoek.assert(t instanceof internals.Any,"Invalid schema object"),Hoek.assert("any"===this._type||"any"===t._type||t._type===this._type,"Cannot merge type",this._type,"with another type:",t._type);let e=this.clone();if("any"===this._type&&"any"!==t._type){const s=t.clone(),n=["_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner"];for(let t=0;t<n.length;++t)s[n[t]]=e[n[t]];e=s}e._settings=e._settings?internals.concatSettings(e._settings,t._settings):t._settings,e._valids.merge(t._valids,t._invalids),e._invalids.merge(t._invalids,t._valids),e._tests=e._tests.concat(t._tests),e._refs=e._refs.concat(t._refs),Hoek.merge(e._flags,t._flags),e._description=t._description||e._description,e._unit=t._unit||e._unit,e._notes=e._notes.concat(t._notes),e._tags=e._tags.concat(t._tags),e._examples=e._examples.concat(t._examples),e._meta=e._meta.concat(t._meta);const s=Object.keys(t._inner),n="object"===e._type;for(let i=0;i<s.length;++i){const r=s[i],a=t._inner[r];if(a){const t=e._inner[r];if(t)if(n&&"children"===r){const e={};for(let s=0;s<t.length;++s)e[t[s].key]=s;for(let s=0;s<a.length;++s){const n=a[s].key;e[n]>=0?t[e[n]]={key:n,schema:t[e[n]].schema.concat(a[s].schema)}:t.push(a[s])}}else e._inner[r]=e._inner[r].concat(a);else e._inner[r]=a.slice()}}return e}_test(t,e,s,n){const i=this.clone();return i._tests.push({func:s,name:t,arg:e,options:n}),i}options(t){Hoek.assert(!t.context,"Cannot override context"),this.checkOptions(t);const e=this.clone();return e._settings=internals.concatSettings(e._settings,t),e}strict(t){const e=this.clone();return e._settings=e._settings||{},e._settings.convert=void 0!==t&&!t,e}raw(t){const e=this.clone();return e._flags.raw=void 0===t||t,e}error(t){Hoek.assert(t&&t instanceof Error,"Must provide a valid Error object");const e=this.clone();return e._flags.error=t,e}_allow(){const t=Hoek.flatten(Array.prototype.slice.call(arguments));for(let e=0;e<t.length;++e){const s=t[e];Hoek.assert(void 0!==s,"Cannot call allow/valid/invalid with undefined"),this._invalids.remove(s),this._valids.add(s,this._refs)}}allow(){const t=this.clone();return t._allow.apply(t,arguments),t}valid(){const t=this.allow.apply(this,arguments);return t._flags.allowOnly=!0,t}invalid(t){const e=this.clone(),s=Hoek.flatten(Array.prototype.slice.call(arguments));for(let n=0;n<s.length;++n)t=s[n],Hoek.assert(void 0!==t,"Cannot call allow/valid/invalid with undefined"),e._valids.remove(t),e._invalids.add(t,this._refs);return e}required(){const t=this.clone();return t._flags.presence="required",t}optional(){const t=this.clone();return t._flags.presence="optional",t}forbidden(){const t=this.clone();return t._flags.presence="forbidden",t}strip(){const t=this.clone();return t._flags.strip=!0,t}applyFunctionToChildren(t,e,s,n){if(1!==(t=[].concat(t)).length||""!==t[0]){n=n?n+".":"";const e=(""===t[0]?t.slice(1):t).map(t=>n+t);throw new Error("unknown key(s) "+e.join(", "))}return this[e].apply(this,s)}default(t,e){"function"!=typeof t||Ref.isRef(t)||(!t.description&&e&&(t.description=e),this._flags.func||Hoek.assert("string"==typeof t.description&&t.description.length>0,"description must be provided when default value is a function"));const s=this.clone();return s._flags.default=t,Ref.push(s._refs,t),s}empty(t){const e=this.clone();return e._flags.empty=void 0===t?void 0:Cast.schema(t),e}when(t,e){Hoek.assert(e&&"object"==typeof e,"Invalid options"),Hoek.assert(void 0!==e.then||void 0!==e.otherwise,'options must have at least one of "then" or "otherwise"');const s=e.hasOwnProperty("then")?this.concat(Cast.schema(e.then)):void 0,n=e.hasOwnProperty("otherwise")?this.concat(Cast.schema(e.otherwise)):void 0,i=(Alternatives=Alternatives||require("./alternatives")).when(t,{is:e.is,then:s,otherwise:n});return i._flags.presence="ignore",i._settings=internals.concatSettings(i._settings,{baseType:this}),i}description(t){Hoek.assert(t&&"string"==typeof t,"Description must be a non-empty string");const e=this.clone();return e._description=t,e}notes(t){Hoek.assert(t&&("string"==typeof t||Array.isArray(t)),"Notes must be a non-empty string or array");const e=this.clone();return e._notes=e._notes.concat(t),e}tags(t){Hoek.assert(t&&("string"==typeof t||Array.isArray(t)),"Tags must be a non-empty string or array");const e=this.clone();return e._tags=e._tags.concat(t),e}meta(t){Hoek.assert(void 0!==t,"Meta cannot be undefined");const e=this.clone();return e._meta=e._meta.concat(t),e}example(t){Hoek.assert(arguments.length,"Missing example");const e=this._validate(t,null,internals.defaults);Hoek.assert(!e.errors,"Bad example:",e.errors&&Errors.process(e.errors,t));const s=this.clone();return s._examples.push(t),s}unit(t){Hoek.assert(t&&"string"==typeof t,"Unit name must be a non-empty string");const e=this.clone();return e._unit=t,e}_validate(t,e,s,n){const i=t;e=e||{key:"",path:"",parent:null,reference:n},this._settings&&(s=internals.concatSettings(s,this._settings));let r=[];const a=()=>{let n;if(!this._flags.strip)if(void 0!==t)n=this._flags.raw?i:t;else if(s.noDefaults)n=i;else if(Ref.isRef(this._flags.default))n=this._flags.default(e.parent,s);else if("function"!=typeof this._flags.default||this._flags.func&&!this._flags.default.description)n=Hoek.clone(this._flags.default);else{let t;null!==e.parent&&this._flags.default.length>0&&(t=[Hoek.clone(e.parent),s]);const i=internals._try(this._flags.default,t);n=i.value,i.error&&r.push(this.createError("any.default",i.error,e,s))}return{value:n,errors:r.length?r:null}};if(this._coerce){const n=this._coerce.call(this,t,e,s);if(n.errors)return t=n.value,r=r.concat(n.errors),a();t=n.value}this._flags.empty&&!this._flags.empty._validate(t,null,internals.defaults).errors&&(t=void 0);const o=this._flags.presence||s.presence;if("optional"===o){if(void 0===t){if(!(this._flags.hasOwnProperty("default")&&void 0===this._flags.default)||"object"!==this._type)return a();t={}}}else{if("required"===o&&void 0===t)return r.push(this.createError("any.required",null,e,s)),a();if("forbidden"===o)return void 0===t?a():(r.push(this.createError("any.unknown",null,e,s)),a())}if(this._valids.has(t,e,s,this._flags.insensitive))return a();if(this._invalids.has(t,e,s,this._flags.insensitive)&&(r.push(this.createError(""===t?"any.empty":"any.invalid",null,e,s)),s.abortEarly||void 0===t))return a();if(this._base){const n=this._base.call(this,t,e,s);if(n.errors)return t=n.value,r=r.concat(n.errors),a();if(n.value!==t){if(t=n.value,this._valids.has(t,e,s,this._flags.insensitive))return a();if(this._invalids.has(t,e,s,this._flags.insensitive)&&(r.push(this.createError(""===t?"any.empty":"any.invalid",null,e,s)),s.abortEarly))return a()}}if(this._flags.allowOnly&&(r.push(this.createError("any.allowOnly",{valids:this._valids.values({stripUndefined:!0})},e,s)),s.abortEarly))return a();for(let n=0;n<this._tests.length;++n){const i=this._tests[n].func.call(this,t,e,s);if(i instanceof Errors.Err){if(r.push(i),s.abortEarly)return a()}else t=i}return a()}_validateWithOptions(t,e,s){e&&this.checkOptions(e);const n=internals.concatSettings(internals.defaults,e),i=this._validate(t,null,n),r=Errors.process(i.errors,t);return s?s(r,i.value):{error:r,value:i.value}}validate(t,e,s){return"function"==typeof e?this._validateWithOptions(t,null,e):this._validateWithOptions(t,e,s)}describe(){const t={type:this._type},e=Object.keys(this._flags);if(e.length)if(["empty","default","lazy","label"].some(t=>this._flags.hasOwnProperty(t))){t.flags={};for(let s=0;s<e.length;++s){const n=e[s];"empty"===n?t.flags[n]=this._flags[n].describe():"default"===n?Ref.isRef(this._flags[n])?t.flags[n]=this._flags[n].toString():"function"==typeof this._flags[n]?t.flags[n]=this._flags[n].description:t.flags[n]=this._flags[n]:"lazy"===n||"label"===n||(t.flags[n]=this._flags[n])}}else t.flags=this._flags;this._description&&(t.description=this._description),this._notes.length&&(t.notes=this._notes),this._tags.length&&(t.tags=this._tags),this._meta.length&&(t.meta=this._meta),this._examples.length&&(t.examples=this._examples),this._unit&&(t.unit=this._unit);const s=this._valids.values();s.length&&(t.valids=s.map(t=>Ref.isRef(t)?t.toString():t));const n=this._invalids.values();n.length&&(t.invalids=n.map(t=>Ref.isRef(t)?t.toString():t)),t.rules=[];for(let e=0;e<this._tests.length;++e){const s=this._tests[e],n={name:s.name};void 0!==s.arg&&(n.arg=Ref.isRef(s.arg)?s.arg.toString():s.arg);const i=s.options;if(i){if(i.hasRef){n.arg={};const t=Object.keys(s.arg);for(let e=0;e<t.length;++e){const i=t[e],r=s.arg[i];n.arg[i]=Ref.isRef(r)?r.toString():r}}"string"==typeof i.description?n.description=i.description:"function"==typeof i.description&&(n.description=i.description(n.arg))}t.rules.push(n)}t.rules.length||delete t.rules;const i=this._getLabel();return i&&(t.label=i),t}label(t){Hoek.assert(t&&"string"==typeof t,"Label name must be a non-empty string");const e=this.clone();return e._flags.label=t,e}_getLabel(t){return this._flags.label||t}},internals.Any.prototype.isImmutable=!0,internals.Any.prototype.only=internals.Any.prototype.equal=internals.Any.prototype.valid,internals.Any.prototype.disallow=internals.Any.prototype.not=internals.Any.prototype.invalid,internals.Any.prototype.exist=internals.Any.prototype.required,internals._try=function(t,e){let s,n;try{n=t.apply(null,e)}catch(t){s=t}return{value:n,error:s}},internals.Set=class{constructor(){this._set=[]}add(t,e){!Ref.isRef(t)&&this.has(t,null,null,!1)||(void 0!==e&&Ref.push(e,t),this._set.push(t))}merge(t,e){for(let e=0;e<t._set.length;++e)this.add(t._set[e]);for(let t=0;t<e._set.length;++t)this.remove(e._set[t])}remove(t){this._set=this._set.filter(e=>t!==e)}has(t,e,s,n){for(let i=0;i<this._set.length;++i){let r=this._set[i];e&&Ref.isRef(r)&&(r=r(e.reference||e.parent,s)),Array.isArray(r)||(r=[r]);for(let e=0;e<r.length;++e){const s=r[e];if(typeof t==typeof s&&(t===s||t instanceof Date&&s instanceof Date&&t.getTime()===s.getTime()||n&&"string"==typeof t&&t.toLowerCase()===s.toLowerCase()||Buffer.isBuffer(t)&&Buffer.isBuffer(s)&&t.length===s.length&&t.toString("binary")===s.toString("binary")))return!0}}return!1}values(t){if(t&&t.stripUndefined){const t=[];for(let e=0;e<this._set.length;++e){const s=this._set[e];void 0!==s&&t.push(s)}return t}return this._set.slice()}},internals.concatSettings=function(t,e){if(!t&&!e)return null;const s={};if(t&&Object.assign(s,t),e){const t=Object.keys(e);for(let n=0;n<t.length;++n){const i=t[n];"language"===i&&s.hasOwnProperty(i)?s[i]=Hoek.applyToDefaults(s[i],e[i]):s[i]=e[i]}}return s};