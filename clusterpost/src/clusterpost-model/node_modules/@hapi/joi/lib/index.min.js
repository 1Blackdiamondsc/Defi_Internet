"use strict";const Hoek=require("@hapi/hoek"),Any=require("./types/any"),Cast=require("./cast"),Errors=require("./errors"),Lazy=require("./types/lazy"),Ref=require("./ref"),internals={alternatives:require("./types/alternatives"),array:require("./types/array"),boolean:require("./types/boolean"),binary:require("./types/binary"),date:require("./types/date"),func:require("./types/func"),number:require("./types/number"),object:require("./types/object"),string:require("./types/string"),symbol:require("./types/symbol"),callWithDefaults:function(e,t){return Hoek.assert(this,"Must be invoked on a Joi instance."),this._defaults&&(e=this._defaults(e)),e._currentJoi=this,e._init(...t)},root:function(){const e=new Any,t=e.clone();return Any.prototype._currentJoi=t,t._currentJoi=t,t._binds=new Set(["any","alternatives","alt","array","bool","boolean","binary","date","func","number","object","string","symbol","validate","describe","compile","assert","attempt","lazy","defaults","extend","allow","valid","only","equal","invalid","disallow","not","required","exist","optional","forbidden","strip","when","empty","default"]),t.any=function(...t){return Hoek.assert(0===t.length,"Joi.any() does not allow arguments."),internals.callWithDefaults.call(this,e,t)},t.alternatives=t.alt=function(...e){return internals.callWithDefaults.call(this,internals.alternatives,e)},t.array=function(...e){return Hoek.assert(0===e.length,"Joi.array() does not allow arguments."),internals.callWithDefaults.call(this,internals.array,e)},t.boolean=t.bool=function(...e){return Hoek.assert(0===e.length,"Joi.boolean() does not allow arguments."),internals.callWithDefaults.call(this,internals.boolean,e)},t.binary=function(...e){return Hoek.assert(0===e.length,"Joi.binary() does not allow arguments."),internals.callWithDefaults.call(this,internals.binary,e)},t.date=function(...e){return Hoek.assert(0===e.length,"Joi.date() does not allow arguments."),internals.callWithDefaults.call(this,internals.date,e)},t.func=function(...e){return Hoek.assert(0===e.length,"Joi.func() does not allow arguments."),internals.callWithDefaults.call(this,internals.func,e)},t.number=function(...e){return Hoek.assert(0===e.length,"Joi.number() does not allow arguments."),internals.callWithDefaults.call(this,internals.number,e)},t.object=function(...e){return internals.callWithDefaults.call(this,internals.object,e)},t.string=function(...e){return Hoek.assert(0===e.length,"Joi.string() does not allow arguments."),internals.callWithDefaults.call(this,internals.string,e)},t.symbol=function(...e){return Hoek.assert(0===e.length,"Joi.symbol() does not allow arguments."),internals.callWithDefaults.call(this,internals.symbol,e)},t.ref=function(...e){return Ref.create(...e)},t.isRef=function(e){return Ref.isRef(e)},t.validate=function(t,...n){const r=n[n.length-1],s="function"==typeof r?r:null,a=n.length-(s?1:0);if(0===a)return e.validate(t,s);const i=2===a?n[1]:void 0;return this.compile(n[0])._validateWithOptions(t,i,s)},t.describe=function(...t){return(t.length?this.compile(t[0]):e).describe()},t.compile=function(e){try{return Cast.schema(this,e)}catch(e){throw e.hasOwnProperty("path")&&(e.message=e.message+"("+e.path+")"),e}},t.assert=function(e,t,n){this.attempt(e,t,n)},t.attempt=function(e,t,n){const r=this.validate(e,t),s=r.error;if(s){if(!n)throw"function"==typeof s.annotate&&(s.message=s.annotate()),s;if(!(n instanceof Error))throw"function"==typeof s.annotate&&(s.message=`${n} ${s.annotate()}`),s;throw n}return r.value},t.reach=function(e,t){Hoek.assert(e&&e instanceof Any,"you must provide a joi schema"),Hoek.assert(Array.isArray(t)||"string"==typeof t,"path must be a string or an array of strings");const n=(e,t)=>{if(!t.length)return e;const r=e._inner.children;if(!r)return;const s=t.shift();for(let e=0;e<r.length;++e){const a=r[e];if(a.key===s)return n(a.schema,t)}},r="string"==typeof t?t?t.split("."):[]:t.slice();return n(e,r)},t.lazy=function(...e){return internals.callWithDefaults.call(this,Lazy,e)},t.defaults=function(e){Hoek.assert("function"==typeof e,"Defaults must be a function");let t=Object.create(this.any());return t=e(t),Hoek.assert(t&&t instanceof this.constructor,"defaults() must return a schema"),Object.assign(t,this,t.clone()),t._defaults=(t=>(this._defaults&&(t=this._defaults(t),Hoek.assert(t instanceof this.constructor,"defaults() must return a schema")),t=e(t),Hoek.assert(t instanceof this.constructor,"defaults() must return a schema"),t)),t},t.bind=function(){const e=Object.create(this);return e._binds.forEach(t=>{e[t]=e[t].bind(e)}),e},t.extend=function(...e){const n=Hoek.flatten(e);Hoek.assert(n.length>0,"You need to provide at least one extension"),this.assert(n,t.extensionsSchema);const r=Object.create(this.any());Object.assign(r,this),r._currentJoi=r,r._binds=new Set(r._binds);for(let e=0;e<n.length;++e){let s=n[e];"function"==typeof s&&(s=s(r)),this.assert(s,t.extensionSchema);const a=(s.base||this.any()).clone(),i=a.constructor,o=class extends i{constructor(){super(),s.base&&Object.assign(this,a),this._type=s.name}};if(s.language){const e={[s.name]:s.language};o.prototype._language=Hoek.applyToDefaults(o.prototype._language||a._settings&&a._settings.language||{},e)}if(s.coerce&&(o.prototype._coerce=function(e,t,n){if(i.prototype._coerce){const r=i.prototype._coerce.call(this,e,t,n);if(r.errors)return r;e=r.value}const r=s.coerce.call(this,e,t,n);return r instanceof Errors.Err?{value:e,errors:r}:{value:r}}),s.pre&&(o.prototype._base=function(e,t,n){if(i.prototype._base){const r=i.prototype._base.call(this,e,t,n);if(r.errors)return r;e=r.value}const r=s.pre.call(this,e,t,n);return r instanceof Errors.Err?{value:e,errors:r}:{value:r}}),s.rules)for(let e=0;e<s.rules.length;++e){const t=s.rules[e],n=t.params?t.params instanceof Any?t.params._inner.children.map(e=>e.key):Object.keys(t.params):[],a=t.params?Cast.schema(this,t.params):null;o.prototype[t.name]=function(...e){if(e.length>n.length)throw new Error("Unexpected number of arguments");let s,i=!1,o={};for(let t=0;t<n.length;++t)o[n[t]]=e[t],!i&&Ref.isRef(e[t])&&(i=!0);if(a&&(o=r.attempt(o,a)),t.validate&&!t.setup){const e=function(e,n,r){return t.validate.call(this,o,e,n,r)};s=this._test(t.name,o,e,{description:t.description,hasRef:i})}else s=this.clone();if(t.setup){const e=t.setup.call(s,o);if(void 0!==e&&(Hoek.assert(e instanceof Any,`Setup of extension Joi.${this._type}().${t.name}() must return undefined or a Joi object`),s=e),t.validate){const e=function(e,n,r){return t.validate.call(this,o,e,n,r)};s=s._test(t.name,o,e,{description:t.description,hasRef:i})}}return s}}s.describe&&(o.prototype.describe=function(){const e=i.prototype.describe.call(this);return s.describe.call(this,e)});const l=new o;r[s.name]=function(...e){return internals.callWithDefaults.call(this,l,e)},r._binds.add(s.name)}return r},t.extensionSchema=internals.object.keys({base:internals.object.type(Any,"Joi object"),name:internals.string.required(),coerce:internals.func.arity(3),pre:internals.func.arity(3),language:internals.object,describe:internals.func.arity(1),rules:internals.array.items(internals.object.keys({name:internals.string.required(),setup:internals.func.arity(1),validate:internals.func.arity(4),params:[internals.object.pattern(/.*/,internals.object.type(Any,"Joi object")),internals.object.type(internals.object.constructor,"Joi object")],description:[internals.string,internals.func.arity(1)]}).or("setup","validate"))}).strict(),t.extensionsSchema=internals.array.items([internals.object,internals.func.arity(1)]).strict(),t.version=require("../package.json").version,t}};module.exports=internals.root();