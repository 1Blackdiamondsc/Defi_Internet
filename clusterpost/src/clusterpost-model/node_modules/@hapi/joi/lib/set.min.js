"use strict";const Ref=require("./ref"),internals={extendedCheckForValue:function(e,t){const s=typeof e;if("object"===s){if(e instanceof Date)return t=>t instanceof Date&&e.getTime()===t.getTime();if(Buffer.isBuffer(e))return t=>Buffer.isBuffer(t)&&e.length===t.length&&e.toString("binary")===t.toString("binary")}else if(t&&"string"===s){const t=e.toLowerCase();return e=>"string"==typeof e&&t===e.toLowerCase()}return null}};module.exports=class e{constructor(e){this._set=new Set(e),this._hasRef=!1}add(e,t){const s=Ref.isRef(e);return!s&&this.has(e,null,null,!1)?this:(void 0!==t&&Ref.push(t,e),this._set.add(e),this._hasRef|=s,this)}merge(e,t){for(const t of e._set)this.add(t);for(const e of t._set)this.remove(e);return this}remove(e){return this._set.delete(e),this}has(e,t,s,r){return!!this.get(e,t,s,r)}get(e,t,s,r){if(!this._set.size)return!1;if(this._set.has(e))return{value:e};const n=internals.extendedCheckForValue(e,r);if(!n){if(t&&this._hasRef)for(let r of this._set)if(Ref.isRef(r)){const n=(r=[].concat(r(t.reference||t.parent,s))).indexOf(e);if(n>=0)return{value:r[n]}}return!1}return this._has(e,t,s,n)}_has(e,t,s,r){const n=!(!t||!this._hasRef),i=function(t){return e===t||r(t)};for(let e of this._set)if(n&&Ref.isRef(e)&&(e=e(t.reference||t.parent,s),Array.isArray(e))){const t=e.findIndex(i);if(t>=0)return{value:e[t]}}else if(i(e))return{value:e};return!1}values(e){if(e&&e.stripUndefined){const e=[];for(const t of this._set)void 0!==t&&e.push(t);return e}return Array.from(this._set)}slice(){const t=new e(this._set);return t._hasRef=this._hasRef,t}concat(t){const s=new e([...this._set,...t._set]);return s._hasRef=!!(this._hasRef|t._hasRef),s}};