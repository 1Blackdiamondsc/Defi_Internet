"use strict";const Hoek=require("@hapi/hoek"),Language=require("./language"),internals={annotations:Symbol("joi-annotations"),stringify:function(t,e){const n=typeof t;if(null===t)return"null";if("string"===n)return t;if(t instanceof exports.Err||"function"===n||"symbol"===n)return t.toString();if("object"===n){if(Array.isArray(t)){let n="";for(let s=0;s<t.length;++s)n=n+(n.length?", ":"")+internals.stringify(t[s],e);return e?"["+n+"]":n}return t.toString()}return JSON.stringify(t)}};exports.Err=class{constructor(t,e,n,s,r,i,o){this.isJoi=!0,this.type=t,this.context=e||{},this.context.key=n.path[n.path.length-1],this.context.label=n.key,this.path=n.path,this.options=s,this.flags=r,this.message=i,this.template=o;const a=this.options.language;this.flags.label?this.context.label=this.flags.label:!a||""!==this.context.label&&null!==this.context.label||(this.context.label=a.root||Language.errors.root)}toString(){if(this.message)return this.message;let t;this.template&&(t=this.template);const e=this.options.language;if(void 0===(t=t||Hoek.reach(e,this.type)||Hoek.reach(Language.errors,this.type)))return`Error code "${this.type}" is not defined, your custom type is missing the correct language definition`;let n=Hoek.reach(e,"messages.wrapArrays");if("boolean"!=typeof n&&(n=Language.errors.messages.wrapArrays),null===t){const t=internals.stringify(this.context.reason,n);return n?t.slice(1,-1):t}const s=/{{!?label}}/.test(t),r=t.length>2&&"!"===t[0]&&"!"===t[1];if(r&&(t=t.slice(2)),!s&&!r){const n=Hoek.reach(e,"key");t="string"==typeof n?n+t:Hoek.reach(Language.errors,"key")+t}const i=t.replace(/{{(!?)([^}]+)}}/g,(t,e,s)=>{const r=Hoek.reach(this.context,s),i=internals.stringify(r,n);return e&&this.options.escapeHtml?Hoek.escapeHtml(i):i});return this.toString=(()=>i),i}},exports.create=function(t,e,n,s,r,i,o){return new exports.Err(t,e,n,s,r,i,o)},exports.process=function(t,e){if(!t)return null;let n="";const s=[],r=function(t,e,i){for(let o=0;o<t.length;++o){const a=t[o];if(a instanceof Error)return a;if(a.flags.error&&"function"!=typeof a.flags.error&&(!a.flags.selfError||!a.context.reason))return a.flags.error;let l;if(void 0===e&&(l=a.toString(),n=n+(n?". ":"")+l),a.context.reason){const t=r(a.context.reason,a.path,"override"===a.type?a.message:null);if(t)return t}else s.push({message:i||l||a.toString(),path:a.path,type:a.type,context:a.context})}},i=r(t);if(i)return i;const o=new Error(n);return o.isJoi=!0,o.name="ValidationError",o.details=s,o._object=e,o.annotate=internals.annotate,o},internals.safeStringify=function(t,e){return JSON.stringify(t,internals.serializer(),e)},internals.serializer=function(){const t=[],e=[];return function(n,s){if(e.length>0){const r=e.indexOf(this);~r?(e.length=r+1,t.length=r+1,t[r]=n):(e.push(this),t.push(n)),~e.indexOf(s)&&(s=((n,s)=>e[0]===s?"[Circular ~]":"[Circular ~."+t.slice(0,e.indexOf(s)).join(".")+"]").call(this,n,s))}else e.push(s);if(s){const t=s[internals.annotations];if(t){if(Array.isArray(s)){const e=[];for(let n=0;n<s.length;++n)t.errors[n]&&e.push(`_$idx$_${t.errors[n].sort().join(", ")}_$end$_`),e.push(s[n]);s=e}else{const e=Object.keys(t.errors);for(let n=0;n<e.length;++n){const r=e[n];s[`${r}_$key$_${t.errors[r].sort().join(", ")}_$end$_`]=s[r],s[r]=void 0}const n=Object.keys(t.missing);for(let e=0;e<n.length;++e){const r=n[e];s[`_$miss$_${r}|${t.missing[r]}_$end$_`]="__missing__"}}return s}}return s===1/0||s===-1/0||Number.isNaN(s)||"function"==typeof s||"symbol"==typeof s?"["+s.toString()+"]":s}},internals.annotate=function(t){const e=t?"":"[31m",n=t?"":"[41m",s=t?"":"[0m";if("object"!=typeof this._object)return this.details[0].message;const r=Hoek.clone(this._object||{});for(let t=this.details.length-1;t>=0;--t){const e=t+1,n=this.details[t],s=n.path;let i=r;for(let t=0;;++t){const r=s[t];if(i.isImmutable&&(i=i.clone()),!(t+1<s.length&&i[r]&&"string"!=typeof i[r])){const t=i[internals.annotations]=i[internals.annotations]||{errors:{},missing:{}},s=i[r],o=r||n.context.label;void 0!==s?(t.errors[o]=t.errors[o]||[],t.errors[o].push(e)):t.missing[o]=e;break}i=i[r]}}const i=/_\$key\$_([, \d]+)_\$end\$_"/g,o=/"_\$miss\$_([^|]+)\|(\d+)_\$end\$_": "__missing__"/g,a=/\s*"_\$idx\$_([, \d]+)_\$end\$_",?\n(.*)/g,l=/"\[(NaN|Symbol.*|-?Infinity|function.*|\(.*)]"/g;let c=internals.safeStringify(r,2).replace(i,(t,n)=>`" ${e}[${n}]${s}`).replace(o,(t,r,i)=>`${n}"${r}"${s}${e} [${i}]: -- missing --${s}`).replace(a,(t,n,r)=>`\n${r} ${e}[${n}]${s}`).replace(l,(t,e)=>e);c=`${c}\n${e}`;for(let t=0;t<this.details.length;++t){c=`${c}\n[${t+1}] ${this.details[t].message}`}return c+=s};