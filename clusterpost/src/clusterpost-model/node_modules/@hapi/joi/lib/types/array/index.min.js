"use strict";const Hoek=require("@hapi/hoek"),Any=require("../any"),Cast=require("../../cast"),Ref=require("../../ref"),State=require("../state"),internals={fastSplice:function(e,r){let t=r;for(;t<e.length;)e[t++]=e[t];--e.length}};internals.Array=class extends Any{constructor(){super(),this._type="array",this._inner.items=[],this._inner.ordereds=[],this._inner.inclusions=[],this._inner.exclusions=[],this._inner.requireds=[],this._flags.sparse=!1}_base(e,r,t){const s={value:e};if("string"==typeof e&&t.convert&&e.length>1&&("["===e[0]||/^\s*\[/.test(e)))try{s.value=JSON.parse(e)}catch(e){}let n=Array.isArray(s.value);const i=n;if(t.convert&&this._flags.single&&!n&&(s.value=[s.value],n=!0),!n)return s.errors=this.createError("array.base",null,r,t),s;if((this._inner.inclusions.length||this._inner.exclusions.length||this._inner.requireds.length||this._inner.ordereds.length||!this._flags.sparse)&&(i&&(s.value=s.value.slice(0)),s.errors=this._checkItems(s.value,i,r,t),s.errors&&i&&t.convert&&this._flags.single)){const e=s.errors;s.value=[s.value],s.errors=this._checkItems(s.value,i,r,t),s.errors&&(s.errors=e,s.value=s.value[0])}return s}_checkItems(e,r,t,s){const n=[];let i;const a=this._inner.requireds.slice(),o=this._inner.ordereds.slice(),l=[...this._inner.inclusions,...a];let h=e.length;for(let u=0;u<h;++u){i=!1;const c=e[u];let p=!1;const f=r?u:t.key,d=r?[...t.path,u]:t.path,g=new State(f,d,t.parent,t.reference);let y;if(!this._flags.sparse&&void 0===c){if(n.push(this.createError("array.sparse",null,{key:t.key,path:g.path,pos:u},s)),s.abortEarly)return n;o.shift();continue}for(let e=0;e<this._inner.exclusions.length;++e)if(!(y=this._inner.exclusions[e]._validate(c,g,{})).errors){if(n.push(this.createError(r?"array.excludes":"array.excludesSingle",{pos:u,value:c},{key:t.key,path:g.path},s)),i=!0,s.abortEarly)return n;o.shift();break}if(i)continue;if(this._inner.ordereds.length){if(o.length>0){const r=o.shift();if((y=r._validate(c,g,s)).errors){if(n.push(this.createError("array.ordered",{pos:u,reason:y.errors,value:c},{key:t.key,path:g.path},s)),s.abortEarly)return n}else if(r._flags.strip)internals.fastSplice(e,u),--u,--h;else{if(!this._flags.sparse&&void 0===y.value){if(n.push(this.createError("array.sparse",null,{key:t.key,path:g.path,pos:u},s)),s.abortEarly)return n;continue}e[u]=y.value}continue}if(!this._inner.items.length){if(n.push(this.createError("array.orderedLength",{pos:u,limit:this._inner.ordereds.length},{key:t.key,path:g.path},s)),s.abortEarly)return n;continue}}const _=[];let k=a.length;for(let r=0;r<k;++r)if(!(y=_[r]=a[r]._validate(c,g,s)).errors){if(e[u]=y.value,p=!0,internals.fastSplice(a,r),--r,--k,!this._flags.sparse&&void 0===y.value&&(n.push(this.createError("array.sparse",null,{key:t.key,path:g.path,pos:u},s)),s.abortEarly))return n;break}if(p)continue;const m=s.stripUnknown&&!!s.stripUnknown.arrays||!1;k=l.length;for(let o=0;o<k;++o){const f=l[o],d=a.indexOf(f);if(-1!==d)y=_[d];else if(!(y=f._validate(c,g,s)).errors){f._flags.strip?(internals.fastSplice(e,u),--u,--h):this._flags.sparse||void 0!==y.value?e[u]=y.value:(n.push(this.createError("array.sparse",null,{key:t.key,path:g.path,pos:u},s)),i=!0),p=!0;break}if(1===k){if(m){internals.fastSplice(e,u),--u,--h,p=!0;break}if(n.push(this.createError(r?"array.includesOne":"array.includesOneSingle",{pos:u,reason:y.errors,value:c},{key:t.key,path:g.path},s)),i=!0,s.abortEarly)return n;break}}if(!i&&(this._inner.inclusions.length&&!p)){if(m){internals.fastSplice(e,u),--u,--h;continue}if(n.push(this.createError(r?"array.includes":"array.includesSingle",{pos:u,value:c},{key:t.key,path:g.path},s)),s.abortEarly)return n}}return a.length&&this._fillMissedErrors(n,a,t,s),o.length&&this._fillOrderedErrors(n,o,t,s),n.length?n:null}describe(){const e=super.describe();if(this._inner.ordereds.length){e.orderedItems=[];for(let r=0;r<this._inner.ordereds.length;++r)e.orderedItems.push(this._inner.ordereds[r].describe())}if(this._inner.items.length){e.items=[];for(let r=0;r<this._inner.items.length;++r)e.items.push(this._inner.items[r].describe())}if(e.rules)for(let r=0;r<e.rules.length;++r){const t=e.rules[r];"has"===t.name&&(t.arg=t.arg.describe())}return e}items(...e){const r=this.clone();return Hoek.flatten(e).forEach((e,t)=>{try{e=Cast.schema(this._currentJoi,e)}catch(e){throw e.hasOwnProperty("path")?e.path=t+"."+e.path:e.path=t,e.message=`${e.message}(${e.path})`,e}r._inner.items.push(e),"required"===e._flags.presence?r._inner.requireds.push(e):"forbidden"===e._flags.presence?r._inner.exclusions.push(e.optional()):r._inner.inclusions.push(e)}),r}ordered(...e){const r=this.clone();return Hoek.flatten(e).forEach((e,t)=>{try{e=Cast.schema(this._currentJoi,e)}catch(e){throw e.hasOwnProperty("path")?e.path=t+"."+e.path:e.path=t,e.message=`${e.message}(${e.path})`,e}r._inner.ordereds.push(e)}),r}min(e){const r=Ref.isRef(e);return Hoek.assert(Number.isSafeInteger(e)&&e>=0||r,"limit must be a positive integer or reference"),this._testUnique("min",e,function(t,s,n){let i;if(r){if(i=e(s.reference||s.parent,n),!(Number.isSafeInteger(i)&&i>=0))return this.createError("array.ref",{ref:e,value:i},s,n)}else i=e;return t.length>=i?t:this.createError("array.min",{limit:e,value:t},s,n)})}max(e){const r=Ref.isRef(e);return Hoek.assert(Number.isSafeInteger(e)&&e>=0||r,"limit must be a positive integer or reference"),this._testUnique("max",e,function(t,s,n){let i;if(r){if(i=e(s.reference||s.parent,n),!(Number.isSafeInteger(i)&&i>=0))return this.createError("array.ref",{ref:e.key},s,n)}else i=e;return t.length<=i?t:this.createError("array.max",{limit:e,value:t},s,n)})}length(e){const r=Ref.isRef(e);return Hoek.assert(Number.isSafeInteger(e)&&e>=0||r,"limit must be a positive integer or reference"),this._testUnique("length",e,function(t,s,n){let i;if(r){if(i=e(s.reference||s.parent,n),!(Number.isSafeInteger(i)&&i>=0))return this.createError("array.ref",{ref:e.key},s,n)}else i=e;return t.length===i?t:this.createError("array.length",{limit:e,value:t},s,n)})}has(e){try{e=Cast.schema(this._currentJoi,e)}catch(e){throw e.hasOwnProperty("path")&&(e.message=`${e.message}(${e.path})`),e}return this._test("has",e,function(r,t,s){if(r.some((r,n)=>{const i=new State(n,[...t.path,n],t.key,t.reference);return!e._validate(r,i,s).errors}))return r;const n=e._getLabel();return n?this.createError("array.hasKnown",{patternLabel:n},t,s):this.createError("array.hasUnknown",null,t,s)})}unique(e,r){Hoek.assert(void 0===e||"function"==typeof e||"string"==typeof e,"comparator must be a function or a string"),Hoek.assert(void 0===r||"object"==typeof r,"configs must be an object");const t={ignoreUndefined:r&&r.ignoreUndefined||!1};return"string"==typeof e?t.path=e:"function"==typeof e&&(t.comparator=e),this._test("unique",t,function(e,r,s){const n={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},i=t.comparator||Hoek.deepEqual,a=t.ignoreUndefined;for(let o=0;o<e.length;++o){const l=t.path?Hoek.reach(e[o],t.path):e[o],h=t.comparator?n.custom:n[typeof l];if(h)if(h instanceof Map){const n=h.entries();let a;for(;!(a=n.next()).done;)if(i(a.value[0],l)){const n=new State(r.key,[...r.path,o],r.parent,r.reference),i={pos:o,value:e[o],dupePos:a.value[1],dupeValue:e[a.value[1]]};return t.path&&(i.path=t.path),this.createError("array.unique",i,n,s)}h.set(l,o)}else{if((!a||void 0!==l)&&void 0!==h[l]){const n=new State(r.key,[...r.path,o],r.parent,r.reference),i={pos:o,value:e[o],dupePos:h[l],dupeValue:e[h[l]]};return t.path&&(i.path=t.path),this.createError("array.unique",i,n,s)}h[l]=o}}return e})}sparse(e){const r=void 0===e||!!e;if(this._flags.sparse===r)return this;const t=this.clone();return t._flags.sparse=r,t}single(e){const r=void 0===e||!!e;if(this._flags.single===r)return this;const t=this.clone();return t._flags.single=r,t}_fillMissedErrors(e,r,t,s){const n=[];let i=0;for(let e=0;e<r.length;++e){const t=r[e]._getLabel();t?n.push(t):++i}n.length?i?e.push(this.createError("array.includesRequiredBoth",{knownMisses:n,unknownMisses:i},{key:t.key,path:t.path},s)):e.push(this.createError("array.includesRequiredKnowns",{knownMisses:n},{key:t.key,path:t.path},s)):e.push(this.createError("array.includesRequiredUnknowns",{unknownMisses:i},{key:t.key,path:t.path},s))}_fillOrderedErrors(e,r,t,s){const n=[];for(let e=0;e<r.length;++e){"required"===Hoek.reach(r[e],"_flags.presence")&&n.push(r[e])}n.length&&this._fillMissedErrors(e,n,t,s)}},module.exports=new internals.Array;