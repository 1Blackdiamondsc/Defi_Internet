"use strict";const Hoek=require("@hapi/hoek"),Settings=require("./settings"),Ref=require("../../ref"),Errors=require("../../errors"),State=require("../state"),Symbols=require("../symbols");let Alternatives=null,Cast=null,Schemas=null;const internals={Set:require("../../set"),defaults:{abortEarly:!0,convert:!0,allowUnknown:!1,skipFunctions:!1,stripUnknown:!1,language:{},presence:"optional",noDefaults:!1,escapeHtml:!1}};module.exports=internals.Any=class{constructor(){Cast=Cast||require("../../cast"),this.isJoi=!0,this._type="any",this._settings=null,this._valids=new internals.Set,this._invalids=new internals.Set,this._tests=[],this._refs=[],this._flags={},this._description=null,this._unit=null,this._notes=[],this._tags=[],this._examples=[],this._meta=[],this._inner={}}_init(){return this}get schemaType(){return this._type}createError(e,t,s,i,n=this._flags){return Errors.create(e,t,s,i,n)}createOverrideError(e,t,s,i,n,r){return Errors.create(e,t,s,i,this._flags,n,r)}checkOptions(e){const t=(Schemas=Schemas||require("../../schemas")).options.validate(e);if(t.error)throw new Error(t.error.details[0].message)}clone(){const e=Object.create(Object.getPrototypeOf(this));e.isJoi=!0,e._currentJoi=this._currentJoi,e._type=this._type,e._settings=this._settings,e._baseType=this._baseType,e._valids=this._valids.slice(),e._invalids=this._invalids.slice(),e._tests=this._tests.slice(),e._refs=this._refs.slice(),e._flags=Hoek.clone(this._flags),e._description=this._description,e._unit=this._unit,e._notes=this._notes.slice(),e._tags=this._tags.slice(),e._examples=this._examples.slice(),e._meta=this._meta.slice(),e._inner={};const t=Object.keys(this._inner);for(let s=0;s<t.length;++s){const i=t[s];e._inner[i]=this._inner[i]?this._inner[i].slice():null}return e}concat(e){Hoek.assert(e instanceof internals.Any,"Invalid schema object"),Hoek.assert("any"===this._type||"any"===e._type||e._type===this._type,"Cannot merge type",this._type,"with another type:",e._type);let t=this.clone();if("any"===this._type&&"any"!==e._type){const s=e.clone(),i=["_settings","_valids","_invalids","_tests","_refs","_flags","_description","_unit","_notes","_tags","_examples","_meta","_inner"];for(let e=0;e<i.length;++e)s[i[e]]=t[i[e]];t=s}if(t._settings=t._settings?Settings.concat(t._settings,e._settings):e._settings,t._valids.merge(e._valids,e._invalids),t._invalids.merge(e._invalids,e._valids),t._tests.push(...e._tests),t._refs.push(...e._refs),t._flags.empty&&e._flags.empty){t._flags.empty=t._flags.empty.concat(e._flags.empty);const s=Object.assign({},e._flags);delete s.empty,Hoek.merge(t._flags,s)}else if(e._flags.empty){t._flags.empty=e._flags.empty;const s=Object.assign({},e._flags);delete s.empty,Hoek.merge(t._flags,s)}else Hoek.merge(t._flags,e._flags);t._description=e._description||t._description,t._unit=e._unit||t._unit,t._notes.push(...e._notes),t._tags.push(...e._tags),t._examples.push(...e._examples),t._meta.push(...e._meta);const s=Object.keys(e._inner),i="object"===t._type;for(let n=0;n<s.length;++n){const r=s[n],a=e._inner[r];if(a){const e=t._inner[r];if(e)if(i&&"children"===r){const t={};for(let s=0;s<e.length;++s)t[e[s].key]=s;for(let s=0;s<a.length;++s){const i=a[s].key;t[i]>=0?e[t[i]]={key:i,schema:e[t[i]].schema.concat(a[s].schema)}:e.push(a[s])}}else t._inner[r]=t._inner[r].concat(a);else t._inner[r]=a.slice()}}return t}_test(e,t,s,i){const n=this.clone();return n._tests.push({func:s,name:e,arg:t,options:i}),n}_testUnique(e,t,s,i){const n=this.clone();return n._tests=n._tests.filter(t=>t.name!==e),n._tests.push({func:s,name:e,arg:t,options:i}),n}options(e){Hoek.assert(!e.context,"Cannot override context"),this.checkOptions(e);const t=this.clone();return t._settings=Settings.concat(t._settings,e),t}strict(e){const t=this.clone(),s=void 0!==e&&!e;return t._settings=Settings.concat(t._settings,{convert:s}),t}raw(e){const t=void 0===e||e;if(this._flags.raw===t)return this;const s=this.clone();return s._flags.raw=t,s}error(e,t={self:!1}){Hoek.assert(e&&(e instanceof Error||"function"==typeof e),"Must provide a valid Error object or a function");const s=Object.keys(t).filter(e=>!["self"].includes(e));Hoek.assert(0===s.length,`Options ${s} are unknown`);const i=this.clone();return i._flags.error=e,t.self&&(i._flags.selfError=!0),i}allow(...e){const t=this.clone();e=Hoek.flatten(e);for(let s=0;s<e.length;++s){const i=e[s];Hoek.assert(void 0!==i,"Cannot call allow/valid/invalid with undefined"),t._invalids.remove(i),t._valids.add(i,t._refs)}return t}valid(...e){const t=this.allow(...e);return t._flags.allowOnly=!0,t}invalid(...e){const t=this.clone();e=Hoek.flatten(e);for(let s=0;s<e.length;++s){const i=e[s];Hoek.assert(void 0!==i,"Cannot call allow/valid/invalid with undefined"),t._valids.remove(i),t._invalids.add(i,t._refs)}return t}required(){if("required"===this._flags.presence)return this;const e=this.clone();return e._flags.presence="required",e}optional(){if("optional"===this._flags.presence)return this;const e=this.clone();return e._flags.presence="optional",e}forbidden(){if("forbidden"===this._flags.presence)return this;const e=this.clone();return e._flags.presence="forbidden",e}strip(){if(this._flags.strip)return this;const e=this.clone();return e._flags.strip=!0,e}applyFunctionToChildren(e,t,s=[],i){if(1!==(e=[].concat(e)).length||""!==e[0]){i=i?i+".":"";const t=(""===e[0]?e.slice(1):e).map(e=>i+e);throw new Error("unknown key(s) "+t.join(", "))}return this[t](...s)}default(e,t){"function"!=typeof e||Ref.isRef(e)||(!e.description&&t&&(e.description=t),this._flags.func||Hoek.assert("string"==typeof e.description&&e.description.length>0,"description must be provided when default value is a function"));const s=this.clone();return s._flags.default=e,Ref.push(s._refs,e),s}empty(e){const t=this.clone();return void 0===e?delete t._flags.empty:t._flags.empty=Cast.schema(this._currentJoi,e),t}when(e,t){Hoek.assert(t&&"object"==typeof t,"Invalid options"),Hoek.assert(void 0!==t.then||void 0!==t.otherwise,'options must have at least one of "then" or "otherwise"');const s=t.hasOwnProperty("then")?this.concat(Cast.schema(this._currentJoi,t.then)):void 0,i=t.hasOwnProperty("otherwise")?this.concat(Cast.schema(this._currentJoi,t.otherwise)):void 0;Alternatives=Alternatives||require("../alternatives");const n={then:s,otherwise:i};Object.prototype.hasOwnProperty.call(t,"is")&&(n.is=t.is);const r=Alternatives.when(e,n);return r._flags.presence="ignore",r._baseType=this,r}description(e){Hoek.assert(e&&"string"==typeof e,"Description must be a non-empty string");const t=this.clone();return t._description=e,t}notes(e){Hoek.assert(e&&("string"==typeof e||Array.isArray(e)),"Notes must be a non-empty string or array");const t=this.clone();return t._notes=t._notes.concat(e),t}tags(e){Hoek.assert(e&&("string"==typeof e||Array.isArray(e)),"Tags must be a non-empty string or array");const t=this.clone();return t._tags=t._tags.concat(e),t}meta(e){Hoek.assert(void 0!==e,"Meta cannot be undefined");const t=this.clone();return t._meta=t._meta.concat(e),t}example(...e){Hoek.assert(e.length>0,"Missing examples");const t=[];for(let s=0;s<e.length;++s){const i=[].concat(e[s]);Hoek.assert(i.length<=2,`Bad example format at index ${s}`);const n=i[0];let r=i[1];if(void 0!==r){Hoek.assert(r&&"object"==typeof r,`Options for example at index ${s} must be an object`);const e=Object.keys(r).filter(e=>!["parent","context"].includes(e));Hoek.assert(0===e.length,`Unknown example options ${e} at index ${s}`)}else r={};const a=new State("",[],r.parent||null),l=this._validate(n,a,Settings.concat(internals.defaults,r.context?{context:r.context}:null));Hoek.assert(!l.errors,`Bad example at index ${s}:`,l.errors&&Errors.process(l.errors,n));const o={value:n};Object.keys(r).length&&(o.options=r),t.push(o)}const s=this.clone();return s._examples=t,s}unit(e){Hoek.assert(e&&"string"==typeof e,"Unit name must be a non-empty string");const t=this.clone();return t._unit=e,t}_prepareEmptyValue(e){return"string"==typeof e&&this._flags.trim?e.trim():e}_validate(e,t,s,i){const n=e;if(t=t||new State("",[],null,i),this._settings){const e=s===internals.defaults;e&&this._settings[Symbols.settingsCache]?s=this._settings[Symbols.settingsCache]:(s=Settings.concat(this._language?Settings.concat({language:this._language},s):s,this._settings),e&&(this._settings[Symbols.settingsCache]=s))}else this._language&&(s=Settings.concat({language:this._language},s));let r=[];if(this._coerce){const i=this._coerce(e,t,s);if(i.errors)return e=i.value,r=r.concat(i.errors),this._finalizeValue(e,n,r,t,s);e=i.value}this._flags.empty&&!this._flags.empty._validate(this._prepareEmptyValue(e),null,internals.defaults).errors&&(e=void 0);const a=this._flags.presence||s.presence;if("optional"===a){if(void 0===e){if(!(this._flags.hasOwnProperty("default")&&void 0===this._flags.default)||"object"!==this._type)return this._finalizeValue(e,n,r,t,s);e={}}}else{if("required"===a&&void 0===e)return r.push(this.createError("any.required",null,t,s)),this._finalizeValue(e,n,r,t,s);if("forbidden"===a)return void 0===e?this._finalizeValue(e,n,r,t,s):(r.push(this.createError("any.unknown",null,t,s)),this._finalizeValue(e,n,r,t,s))}let l=this._valids.get(e,t,s,this._flags.insensitive);if(l)return s.convert&&(e=l.value),this._finalizeValue(e,n,r,t,s);if(this._invalids.has(e,t,s,this._flags.insensitive)&&(r.push(this.createError(""===e?"any.empty":"any.invalid",{value:e,invalids:this._invalids.values({stripUndefined:!0})},t,s)),s.abortEarly))return this._finalizeValue(e,n,r,t,s);if(this._base){const i=this._base(e,t,s);if(i.errors)return e=i.value,r=r.concat(i.errors),this._finalizeValue(e,n,r,t,s);if(i.value!==e){if(e=i.value,l=this._valids.get(e,t,s,this._flags.insensitive))return e=l.value,this._finalizeValue(e,n,r,t,s);if(this._invalids.has(e,t,s,this._flags.insensitive)&&(r.push(this.createError(""===e?"any.empty":"any.invalid",{value:e,invalids:this._invalids.values({stripUndefined:!0})},t,s)),s.abortEarly))return this._finalizeValue(e,n,r,t,s)}}if(this._flags.allowOnly&&(r.push(this.createError("any.allowOnly",{value:e,valids:this._valids.values({stripUndefined:!0})},t,s)),s.abortEarly))return this._finalizeValue(e,n,r,t,s);for(let i=0;i<this._tests.length;++i){const a=this._tests[i].func.call(this,e,t,s);if(a instanceof Errors.Err){if(r.push(a),s.abortEarly)return this._finalizeValue(e,n,r,t,s)}else e=a}return this._finalizeValue(e,n,r,t,s)}_finalizeValue(e,t,s,i,n){let r;if(void 0!==e)r=this._flags.raw?t:e;else if(n.noDefaults)r=e;else if(Ref.isRef(this._flags.default))r=this._flags.default(i.parent,n);else if("function"!=typeof this._flags.default||this._flags.func&&!this._flags.default.description)r=Hoek.clone(this._flags.default);else{let e;null!==i.parent&&this._flags.default.length>0&&(e=[Hoek.clone(i.parent),n]);const t=internals._try(this._flags.default,e);r=t.value,t.error&&s.push(this.createError("any.default",{error:t.error},i,n))}if(s.length&&"function"==typeof this._flags.error&&(!this._flags.selfError||s.some(e=>i.path.length===e.path.length))){const e=this._flags.error.call(this,s);s="string"==typeof e?[this.createOverrideError("override",{reason:s},i,n,e)]:[].concat(e).map(e=>e instanceof Error?e:this.createOverrideError(e.type||"override",e.context,i,n,e.message,e.template))}return{value:this._flags.strip?void 0:r,finalValue:r,errors:s.length?s:null}}_validateWithOptions(e,t,s){t&&this.checkOptions(t);const i=Settings.concat(internals.defaults,t),n=this._validate(e,null,i),r=Errors.process(n.errors,e);return s?s(r,n.value):{error:r,value:n.value,then:(e,t)=>r?Promise.reject(r).catch(t):Promise.resolve(n.value).then(e),catch:e=>r?Promise.reject(r).catch(e):Promise.resolve(n.value)}}validate(e,t,s){return"function"==typeof t?this._validateWithOptions(e,null,t):this._validateWithOptions(e,t,s)}describe(){const e={type:this._type},t=Object.keys(this._flags);if(t.length)if(["empty","default","lazy","label"].some(e=>this._flags.hasOwnProperty(e))){e.flags={};for(let s=0;s<t.length;++s){const i=t[s];"empty"===i?e.flags[i]=this._flags[i].describe():"default"===i?Ref.isRef(this._flags[i])?e.flags[i]=this._flags[i].toString():"function"==typeof this._flags[i]?e.flags[i]={description:this._flags[i].description,function:this._flags[i]}:e.flags[i]=this._flags[i]:"lazy"===i||"label"===i||(e.flags[i]=this._flags[i])}}else e.flags=this._flags;this._settings&&(e.options=Hoek.clone(this._settings)),this._baseType&&(e.base=this._baseType.describe()),this._description&&(e.description=this._description),this._notes.length&&(e.notes=this._notes),this._tags.length&&(e.tags=this._tags),this._meta.length&&(e.meta=this._meta),this._examples.length&&(e.examples=this._examples),this._unit&&(e.unit=this._unit);const s=this._valids.values();s.length&&(e.valids=s.map(e=>Ref.isRef(e)?e.toString():e));const i=this._invalids.values();i.length&&(e.invalids=i.map(e=>Ref.isRef(e)?e.toString():e)),e.rules=[];for(let t=0;t<this._tests.length;++t){const s=this._tests[t],i={name:s.name};void 0!==s.arg&&(i.arg=Ref.isRef(s.arg)?s.arg.toString():s.arg);const n=s.options;if(n){if(n.hasRef){i.arg={};const e=Object.keys(s.arg);for(let t=0;t<e.length;++t){const n=e[t],r=s.arg[n];i.arg[n]=Ref.isRef(r)?r.toString():r}}"string"==typeof n.description?i.description=n.description:"function"==typeof n.description&&(i.description=n.description(i.arg))}e.rules.push(i)}e.rules.length||delete e.rules;const n=this._getLabel();return n&&(e.label=n),e}label(e){Hoek.assert(e&&"string"==typeof e,"Label name must be a non-empty string");const t=this.clone();return t._flags.label=e,t}_getLabel(e){return this._flags.label||e}},internals.Any.prototype.isImmutable=!0,internals.Any.prototype.only=internals.Any.prototype.equal=internals.Any.prototype.valid,internals.Any.prototype.disallow=internals.Any.prototype.not=internals.Any.prototype.invalid,internals.Any.prototype.exist=internals.Any.prototype.required,internals._try=function(e,t=[]){let s,i;try{i=e(...t)}catch(e){s=e}return{value:i,error:s}};