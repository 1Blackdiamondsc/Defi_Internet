"use strict";const Hoek=require("@hapi/hoek"),Any=require("../any"),internals={Set:require("../../set")};internals.Boolean=class extends Any{constructor(){super(),this._type="boolean",this._flags.insensitive=!0,this._inner.truthySet=new internals.Set,this._inner.falsySet=new internals.Set}_base(e,t,n){const s={value:e};if("string"==typeof e&&n.convert){const t=this._flags.insensitive?e.toLowerCase():e;s.value="true"===t||"false"!==t&&e}return"boolean"!=typeof s.value&&(s.value=!!this._inner.truthySet.has(e,null,null,this._flags.insensitive)||!this._inner.falsySet.has(e,null,null,this._flags.insensitive)&&e),s.errors="boolean"==typeof s.value?null:this.createError("boolean.base",{value:e},t,n),s}truthy(...e){const t=this.clone();e=Hoek.flatten(e);for(let n=0;n<e.length;++n){const s=e[n];Hoek.assert(void 0!==s,"Cannot call truthy with undefined"),t._inner.truthySet.add(s)}return t}falsy(...e){const t=this.clone();e=Hoek.flatten(e);for(let n=0;n<e.length;++n){const s=e[n];Hoek.assert(void 0!==s,"Cannot call falsy with undefined"),t._inner.falsySet.add(s)}return t}insensitive(e){const t=void 0===e||!!e;if(this._flags.insensitive===t)return this;const n=this.clone();return n._flags.insensitive=t,n}describe(){const e=super.describe();return e.truthy=[!0,...this._inner.truthySet.values()],e.falsy=[!1,...this._inner.falsySet.values()],e}},module.exports=new internals.Boolean;