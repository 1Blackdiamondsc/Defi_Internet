"use strict";const Hoek=require("@hapi/hoek"),Topo=require("@hapi/topo"),Any=require("../any"),Errors=require("../../errors"),Cast=require("../../cast"),State=require("../state"),internals={};internals.Object=class extends Any{constructor(){super(),this._type="object",this._inner.children=null,this._inner.renames=[],this._inner.dependencies=[],this._inner.patterns=[]}_init(...e){return e.length?this.keys(...e):this}_base(e,t,n){let r=e;const s=[],i=()=>({value:r,errors:s.length?s:null});if("string"==typeof e&&n.convert&&e.length>1&&("{"===e[0]||/^\s*\{/.test(e)))try{e=JSON.parse(e)}catch(e){}const o=this._flags.func?"function":"object";if(!e||typeof e!==o||Array.isArray(e))return s.push(this.createError(o+".base",{value:e},t,n)),i();if(!(this._inner.renames.length||this._inner.dependencies.length||this._inner.children||this._inner.patterns.length))return r=e,i();if(r===e){"object"===o?r=Object.create(Object.getPrototypeOf(e)):(r=function(...t){return e.apply(this,t)}).prototype=Hoek.clone(e.prototype);const t=Object.keys(e);for(let n=0;n<t.length;++n)r[t[n]]=e[t[n]]}else r=e;const a={};for(let e=0;e<this._inner.renames.length;++e){const o=this._inner.renames[e];if(o.isRegExp){const e=Object.keys(r),l=[];for(let t=0;t<e.length;++t)o.from.test(e[t])&&l.push(e[t]);const h=l.every(e=>void 0===r[e]);if(o.options.ignoreUndefined&&h)continue;if(!o.options.multiple&&a[o.to]&&(s.push(this.createError("object.rename.regex.multiple",{from:l,to:o.to},t,n)),n.abortEarly))return i();if(Object.prototype.hasOwnProperty.call(r,o.to)&&!o.options.override&&!a[o.to]&&(s.push(this.createError("object.rename.regex.override",{from:l,to:o.to},t,n)),n.abortEarly))return i();if(h?delete r[o.to]:r[o.to]=r[l[l.length-1]],a[o.to]=!0,!o.options.alias)for(let e=0;e<l.length;++e)delete r[l[e]]}else{if(o.options.ignoreUndefined&&void 0===r[o.from])continue;if(!o.options.multiple&&a[o.to]&&(s.push(this.createError("object.rename.multiple",{from:o.from,to:o.to},t,n)),n.abortEarly))return i();if(Object.prototype.hasOwnProperty.call(r,o.to)&&!o.options.override&&!a[o.to]&&(s.push(this.createError("object.rename.override",{from:o.from,to:o.to},t,n)),n.abortEarly))return i();void 0===r[o.from]?delete r[o.to]:r[o.to]=r[o.from],a[o.to]=!0,o.options.alias||delete r[o.from]}}if(!this._inner.children&&!this._inner.patterns.length&&!this._inner.dependencies.length)return i();const l=new Set(Object.keys(r));if(this._inner.children){const e=[];for(let o=0;o<this._inner.children.length;++o){const a=this._inner.children[o],h=a.key,c=r[h];l.delete(h);const u=new State(h,[...t.path,h],r,t.reference),p=a.schema._validate(c,u,n);if(p.errors){if(s.push(this.createError("object.child",{key:h,child:a.schema._getLabel(h),reason:p.errors},u,n)),n.abortEarly)return i()}else a.schema._flags.strip||void 0===p.value&&p.value!==c?(e.push(h),r[h]=p.finalValue):void 0!==p.value&&(r[h]=p.value)}for(let t=0;t<e.length;++t)delete r[e[t]]}if(l.size&&this._inner.patterns.length)for(const e of l){const o=new State(e,[...t.path,e],r,t.reference),a=r[e];for(let h=0;h<this._inner.patterns.length;++h){const c=this._inner.patterns[h];if(c.regex?c.regex.test(e):!c.schema._validate(e,t,{...n,abortEarly:!0}).errors){l.delete(e);const t=c.rule._validate(a,o,n);if(t.errors&&(s.push(this.createError("object.child",{key:e,child:c.rule._getLabel(e),reason:t.errors},o,n)),n.abortEarly))return i();r[e]=t.value}}}if(l.size&&(this._inner.children||this._inner.patterns.length)){if(n.stripUnknown&&!0!==this._flags.allowUnknown||n.skipFunctions){const e=!!n.stripUnknown&&(!0===n.stripUnknown||!!n.stripUnknown.objects);for(const t of l)e?(delete r[t],l.delete(t)):"function"==typeof r[t]&&l.delete(t)}if(void 0!==this._flags.allowUnknown?!this._flags.allowUnknown:!n.allowUnknown)for(const e of l)s.push(this.createError("object.allowUnknown",{child:e,value:r[e]},{key:e,path:[...t.path,e]},n,{}))}for(let e=0;e<this._inner.dependencies.length;++e){const o=this._inner.dependencies[e],a=null!==o.key,l=a&&o.key.split("."),h=a?new State(l[l.length-1],[...t.path,...l]):new State(null,t.path),c=internals[o.type].call(this,o.key,a&&Hoek.reach(r,o.key,{functions:!0}),o.peers,r,h,n);if(c instanceof Errors.Err&&(s.push(c),n.abortEarly))return i()}return i()}keys(e){Hoek.assert(null==e||"object"==typeof e,"Object schema must be a valid object"),Hoek.assert(!(e&&e instanceof Any),"Object schema cannot be a joi schema");const t=this.clone();if(!e)return t._inner.children=null,t;const n=Object.keys(e);if(!n.length)return t._inner.children=[],t;const r=new Topo;if(t._inner.children)for(let e=0;e<t._inner.children.length;++e){const s=t._inner.children[e];n.includes(s.key)||r.add(s,{after:s._refs,group:s.key})}for(let t=0;t<n.length;++t){const s=n[t],i=e[s];try{const e=Cast.schema(this._currentJoi,i);r.add({key:s,schema:e},{after:e._refs,group:s})}catch(e){throw e.hasOwnProperty("path")?e.path=s+"."+e.path:e.path=s,e}}return t._inner.children=r.nodes,t}append(e){return null==e||0===Object.keys(e).length?this:this.keys(e)}unknown(e){const t=!1!==e;if(this._flags.allowUnknown===t)return this;const n=this.clone();return n._flags.allowUnknown=t,n}length(e){return Hoek.assert(Number.isSafeInteger(e)&&e>=0,"limit must be a positive integer"),this._test("length",e,function(t,n,r){return Object.keys(t).length===e?t:this.createError("object.length",{limit:e,value:t},n,r)})}min(e){return Hoek.assert(Number.isSafeInteger(e)&&e>=0,"limit must be a positive integer"),this._test("min",e,function(t,n,r){return Object.keys(t).length>=e?t:this.createError("object.min",{limit:e,value:t},n,r)})}max(e){return Hoek.assert(Number.isSafeInteger(e)&&e>=0,"limit must be a positive integer"),this._test("max",e,function(t,n,r){return Object.keys(t).length<=e?t:this.createError("object.max",{limit:e,value:t},n,r)})}pattern(e,t){const n=e instanceof RegExp;Hoek.assert(n||e instanceof Any,"pattern must be a regex or schema"),Hoek.assert(void 0!==t,"Invalid rule"),n&&Hoek.assert(!e.flags.includes("g")&&!e.flags.includes("y"),"pattern should not use global or sticky mode");try{t=Cast.schema(this._currentJoi,t)}catch(e){throw e.hasOwnProperty("path")&&(e.message=`${e.message}(${e.path})`),e}const r=this.clone();return n?r._inner.patterns.push({regex:e,rule:t}):r._inner.patterns.push({schema:e,rule:t}),r}schema(){return this._test("schema",null,function(e,t,n){return e instanceof Any?e:this.createError("object.schema",null,t,n)})}with(e,t){return Hoek.assert(2===arguments.length,"Invalid number of arguments, expected 2."),this._dependency("with",e,t)}without(e,t){return Hoek.assert(2===arguments.length,"Invalid number of arguments, expected 2."),this._dependency("without",e,t)}xor(...e){return e=Hoek.flatten(e),this._dependency("xor",null,e)}oxor(...e){return this._dependency("oxor",null,e)}or(...e){return e=Hoek.flatten(e),this._dependency("or",null,e)}and(...e){return e=Hoek.flatten(e),this._dependency("and",null,e)}nand(...e){return e=Hoek.flatten(e),this._dependency("nand",null,e)}requiredKeys(...e){return e=Hoek.flatten(e),this.applyFunctionToChildren(e,"required")}optionalKeys(...e){return e=Hoek.flatten(e),this.applyFunctionToChildren(e,"optional")}forbiddenKeys(...e){return e=Hoek.flatten(e),this.applyFunctionToChildren(e,"forbidden")}rename(e,t,n){Hoek.assert("string"==typeof e||e instanceof RegExp,"Rename missing the from argument"),Hoek.assert("string"==typeof t,"Rename missing the to argument"),Hoek.assert(t!==e,"Cannot rename key to same name:",e);for(let t=0;t<this._inner.renames.length;++t)Hoek.assert(this._inner.renames[t].from!==e,"Cannot rename the same key multiple times");const r=this.clone();return r._inner.renames.push({from:e,to:t,options:Hoek.applyToDefaults(internals.renameDefaults,n||{}),isRegExp:e instanceof RegExp}),r}applyFunctionToChildren(e,t,n=[],r){e=[].concat(e),Hoek.assert(e.length>0,"expected at least one children");const s=internals.groupChildren(e);let i;if(""in s?(i=this[t](...n),delete s[""]):i=this.clone(),i._inner.children){r=r?r+".":"";for(let e=0;e<i._inner.children.length;++e){const o=i._inner.children[e],a=s[o.key];a&&(i._inner.children[e]={key:o.key,_refs:o._refs,schema:o.schema.applyFunctionToChildren(a,t,n,r+o.key)},delete s[o.key])}}const o=Object.keys(s);return Hoek.assert(0===o.length,"unknown key(s)",o.join(", ")),i}_dependency(e,t,n){n=[].concat(n);for(let t=0;t<n.length;++t)Hoek.assert("string"==typeof n[t],e,"peers must be a string or array of strings");const r=this.clone();return r._inner.dependencies.push({type:e,key:t,peers:n}),r}describe(e){const t=super.describe();if(t.rules)for(let e=0;e<t.rules.length;++e){const n=t.rules[e];n.arg&&"object"==typeof n.arg&&n.arg.schema&&n.arg.ref&&(n.arg={schema:n.arg.schema.describe(),ref:n.arg.ref.toString()})}if(this._inner.children&&!e){t.children={};for(let e=0;e<this._inner.children.length;++e){const n=this._inner.children[e];t.children[n.key]=n.schema.describe()}}if(this._inner.dependencies.length&&(t.dependencies=Hoek.clone(this._inner.dependencies)),this._inner.patterns.length){t.patterns=[];for(let e=0;e<this._inner.patterns.length;++e){const n=this._inner.patterns[e];n.regex?t.patterns.push({regex:n.regex.toString(),rule:n.rule.describe()}):t.patterns.push({schema:n.schema.describe(),rule:n.rule.describe()})}}return this._inner.renames.length>0&&(t.renames=Hoek.clone(this._inner.renames)),t}assert(e,t,n){e=Cast.ref(e),Hoek.assert(e.isContext||e.depth>1,"Cannot use assertions for root level references - use direct key rules instead"),n=n||"pass the assertion test",Hoek.assert("string"==typeof n,"Message must be a string");try{t=Cast.schema(this._currentJoi,t)}catch(e){throw e.hasOwnProperty("path")&&(e.message=`${e.message}(${e.path})`),e}const r=e.path[e.path.length-1],s=e.path.join(".");return this._test("assert",{schema:t,ref:e},function(i,o,a){if(!t._validate(e(i),null,a,i).errors)return i;const l=new State(r,e.path,o.parent,o.reference);return this.createError("object.assert",{ref:s,message:n},l,a)})}type(e,t=e.name){Hoek.assert("function"==typeof e,"type must be a constructor function");const n={name:t,ctor:e};return this._test("type",n,function(t,r,s){return t instanceof e?t:this.createError("object.type",{type:n.name,value:t},r,s)})}},internals.renameDefaults={alias:!1,multiple:!1,override:!1},internals.groupChildren=function(e){e.sort();const t={};for(let n=0;n<e.length;++n){const r=e[n];Hoek.assert("string"==typeof r,"children must be strings");const s=r.split(".")[0];(t[s]=t[s]||[]).push(r.substring(s.length+1))}return t},internals.keysToLabels=function(e,t){if(!e._inner.children)return t;const n=function(t){const n=e._currentJoi.reach(e,t);return n?n._getLabel(t):t};return Array.isArray(t)?t.map(n):n(t)},internals.with=function(e,t,n,r,s,i){if(void 0!==t)for(let t=0;t<n.length;++t){const o=n[t];if(void 0===Hoek.reach(r,o,{functions:!0}))return this.createError("object.with",{main:e,mainWithLabel:internals.keysToLabels(this,e),peer:o,peerWithLabel:internals.keysToLabels(this,o)},s,i)}},internals.without=function(e,t,n,r,s,i){if(void 0!==t)for(let t=0;t<n.length;++t){const o=n[t];if(void 0!==Hoek.reach(r,o,{functions:!0}))return this.createError("object.without",{main:e,mainWithLabel:internals.keysToLabels(this,e),peer:o,peerWithLabel:internals.keysToLabels(this,o)},s,i)}},internals.xor=function(e,t,n,r,s,i){const o=[];for(let e=0;e<n.length;++e){const t=n[e];void 0!==Hoek.reach(r,t,{functions:!0})&&o.push(t)}if(1===o.length)return;const a={peers:n,peersWithLabels:internals.keysToLabels(this,n)};return 0===o.length?this.createError("object.missing",a,s,i):(a.present=o,a.presentWithLabels=internals.keysToLabels(this,o),this.createError("object.xor",a,s,i))},internals.oxor=function(e,t,n,r,s,i){const o=[];for(let e=0;e<n.length;++e){const t=n[e];void 0!==Hoek.reach(r,t,{functions:!0})&&o.push(t)}if(!o.length||1===o.length)return;const a={peers:n,peersWithLabels:internals.keysToLabels(this,n)};return a.present=o,a.presentWithLabels=internals.keysToLabels(this,o),this.createError("object.oxor",a,s,i)},internals.or=function(e,t,n,r,s,i){for(let e=0;e<n.length;++e){const t=n[e];if(void 0!==Hoek.reach(r,t,{functions:!0}))return}return this.createError("object.missing",{peers:n,peersWithLabels:internals.keysToLabels(this,n)},s,i)},internals.and=function(e,t,n,r,s,i){const o=[],a=[],l=n.length;for(let e=0;e<l;++e){const t=n[e];void 0===Hoek.reach(r,t,{functions:!0})?o.push(t):a.push(t)}if(!(o.length===l||a.length===l))return this.createError("object.and",{present:a,presentWithLabels:internals.keysToLabels(this,a),missing:o,missingWithLabels:internals.keysToLabels(this,o)},s,i)},internals.nand=function(e,t,n,r,s,i){const o=[];for(let e=0;e<n.length;++e){const t=n[e];void 0!==Hoek.reach(r,t,{functions:!0})&&o.push(t)}const a=n[0],l=n.slice(1);return o.length===n.length?this.createError("object.nand",{main:a,mainWithLabel:internals.keysToLabels(this,a),peers:l,peersWithLabels:internals.keysToLabels(this,l)},s,i):null},module.exports=new internals.Object;