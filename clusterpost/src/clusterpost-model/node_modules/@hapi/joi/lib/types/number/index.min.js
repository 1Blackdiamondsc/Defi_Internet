"use strict";const Hoek=require("@hapi/hoek"),Any=require("../any"),Ref=require("../../ref"),internals={precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,normalizeExponent:e=>e.replace(/\.?0+e/,"e").replace(/e\+/,"e").replace(/^\+/,"").replace(/^(-?)0+([1-9])/,"$1$2"),normalizeDecimal:e=>((e=e.replace(/^\+/,"").replace(/\.0+$/,"").replace(/^(-?)0+([1-9])/,"$1$2")).includes(".")&&e.endsWith("0")&&(e=e.replace(/0+$/,"")),e)};internals.Number=class extends Any{constructor(){super(),this._type="number",this._flags.unsafe=!1,this._invalids.add(1/0),this._invalids.add(-1/0)}_base(e,r,t){const n={errors:null,value:e};if("string"==typeof e&&t.convert){const i=e.match(/^\s*[+-]?\d+(?:\.\d+)?(?:e([+-]?\d+))?\s*$/i);if(i&&(e=e.trim(),n.value=parseFloat(e),!this._flags.unsafe))if(e.includes("e")){if(internals.normalizeExponent(`${n.value/Math.pow(10,i[1])}e${i[1]}`)!==internals.normalizeExponent(e))return n.errors=this.createError("number.unsafe",{value:e},r,t),n}else if(n.value.toString()!==internals.normalizeDecimal(e))return n.errors=this.createError("number.unsafe",{value:e},r,t),n}const i="number"==typeof n.value&&!isNaN(n.value);if(t.convert&&"precision"in this._flags&&i){const e=Math.pow(10,this._flags.precision);n.value=Math.round(n.value*e)/e}return i?!this._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(n.errors=this.createError("number.unsafe",{value:e},r,t)):n.errors=this.createError("number.base",{value:e},r,t),n}multiple(e){const r=Ref.isRef(e);return r||(Hoek.assert("number"==typeof e&&isFinite(e),"multiple must be a number"),Hoek.assert(e>0,"multiple must be greater than 0")),this._test("multiple",e,function(t,n,i){const s=r?e(n.reference||n.parent,i):e;return!r||"number"==typeof s&&isFinite(s)?t%s==0?t:this.createError("number.multiple",{multiple:e,value:t},n,i):this.createError("number.ref",{ref:e.key},n,i)})}integer(){return this._test("integer",void 0,function(e,r,t){return Math.trunc(e)-e==0?e:this.createError("number.integer",{value:e},r,t)})}unsafe(e=!0){if(Hoek.assert("boolean"==typeof e,"enabled must be a boolean"),this._flags.unsafe===e)return this;const r=this.clone();return r._flags.unsafe=e,r}negative(){return this._test("negative",void 0,function(e,r,t){return e<0?e:this.createError("number.negative",{value:e},r,t)})}positive(){return this._test("positive",void 0,function(e,r,t){return e>0?e:this.createError("number.positive",{value:e},r,t)})}precision(e){Hoek.assert(Number.isSafeInteger(e),"limit must be an integer"),Hoek.assert(!("precision"in this._flags),"precision already set");const r=this._test("precision",e,function(r,t,n){const i=r.toString().match(internals.precisionRx);return Math.max((i[1]?i[1].length:0)-(i[2]?parseInt(i[2],10):0),0)<=e?r:this.createError("number.precision",{limit:e,value:r},t,n)});return r._flags.precision=e,r}port(){return this._test("port",void 0,function(e,r,t){return!Number.isSafeInteger(e)||e<0||e>65535?this.createError("number.port",{value:e},r,t):e})}},internals.compare=function(e,r){return function(t){const n=Ref.isRef(t),i="number"==typeof t&&!isNaN(t);return Hoek.assert(i||n,"limit must be a number or reference"),this._test(e,t,function(i,s,a){let o;if(n){if("number"!=typeof(o=t(s.reference||s.parent,a))||isNaN(o))return this.createError("number.ref",{ref:t.key},s,a)}else o=t;return r(i,o)?i:this.createError("number."+e,{limit:o,value:i},s,a)})}},internals.Number.prototype.min=internals.compare("min",(e,r)=>e>=r),internals.Number.prototype.max=internals.compare("max",(e,r)=>e<=r),internals.Number.prototype.greater=internals.compare("greater",(e,r)=>e>r),internals.Number.prototype.less=internals.compare("less",(e,r)=>e<r),module.exports=new internals.Number;