"use strict";const Hoek=require("@hapi/hoek"),Any=require("../any"),Cast=require("../../cast"),Ref=require("../../ref"),internals={};internals.Alternatives=class extends Any{constructor(){super(),this._type="alternatives",this._invalids.remove(null),this._inner.matches=[]}_init(...e){return e.length?this.try(...e):this}_base(e,s,t){const r=[],n=this._inner.matches.length,i=this._baseType;for(let h=0;h<n;++h){const a=this._inner.matches[h];if(!a.schema){const r=a.peek||a.is,o=a.is?a.ref(s.reference||s.parent,t):e;if(r._validate(o,null,t,s.parent).errors){if(a.otherwise)return a.otherwise._validate(e,s,t)}else if(a.then)return a.then._validate(e,s,t);if(h===n-1&&i)return i._validate(e,s,t);continue}const o=a.schema._validate(e,s,t);if(!o.errors)return o;r.push(...o.errors)}return r.length?{errors:this.createError("alternatives.child",{reason:r},s,t)}:{errors:this.createError("alternatives.base",null,s,t)}}try(...e){e=Hoek.flatten(e),Hoek.assert(e.length,"Cannot add other alternatives without at least one schema");const s=this.clone();for(let t=0;t<e.length;++t){const r=Cast.schema(this._currentJoi,e[t]);r._refs.length&&s._refs.push(...r._refs),s._inner.matches.push({schema:r})}return s}when(e,s){let t=!1;Hoek.assert(Ref.isRef(e)||"string"==typeof e||(t=e instanceof Any),"Invalid condition:",e),Hoek.assert(s,"Missing options"),Hoek.assert("object"==typeof s,"Invalid options"),t?Hoek.assert(!s.hasOwnProperty("is"),'"is" can not be used with a schema condition'):Hoek.assert(s.hasOwnProperty("is"),'Missing "is" directive'),Hoek.assert(void 0!==s.then||void 0!==s.otherwise,'options must have at least one of "then" or "otherwise"');const r=this.clone();let n;t||(n=Cast.schema(this._currentJoi,s.is),null!==s.is&&(Ref.isRef(s.is)||s.is instanceof Any)||(n=n.required()));const i={ref:t?null:Cast.ref(e),peek:t?e:null,is:n,then:void 0!==s.then?Cast.schema(this._currentJoi,s.then):void 0,otherwise:void 0!==s.otherwise?Cast.schema(this._currentJoi,s.otherwise):void 0};return r._baseType&&(i.then=i.then&&r._baseType.concat(i.then),i.otherwise=i.otherwise&&r._baseType.concat(i.otherwise)),t||(Ref.push(r._refs,i.ref),r._refs.push(...i.is._refs)),i.then&&i.then._refs.length&&r._refs.push(...i.then._refs),i.otherwise&&i.otherwise._refs.length&&r._refs.push(...i.otherwise._refs),r._inner.matches.push(i),r}label(e){const s=super.label(e);return s._inner.matches=s._inner.matches.map(s=>s.schema?{schema:s.schema.label(e)}:((s=Object.assign({},s)).then&&(s.then=s.then.label(e)),s.otherwise&&(s.otherwise=s.otherwise.label(e)),s)),s}describe(){const e=super.describe(),s=[];for(let e=0;e<this._inner.matches.length;++e){const t=this._inner.matches[e];if(t.schema)s.push(t.schema.describe());else{const e=t.is?{ref:t.ref.toString(),is:t.is.describe()}:{peek:t.peek.describe()};t.then&&(e.then=t.then.describe()),t.otherwise&&(e.otherwise=t.otherwise.describe()),s.push(e)}}return e.alternatives=s,e}},module.exports=new internals.Alternatives;