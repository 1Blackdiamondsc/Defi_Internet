"use strict";const Util=require("util"),Hoek=require("@hapi/hoek"),Any=require("../any"),internals={};internals.Map=class extends Map{slice(){return new internals.Map(this)}toString(){return Util.inspect(this)}},internals.Symbol=class extends Any{constructor(){super(),this._type="symbol",this._inner.map=new internals.Map}_base(e,t,r){if(r.convert){const s=this._inner.map.get(e);if(s&&(e=s),this._flags.allowOnly)return{value:e,errors:"symbol"==typeof e?null:this.createError("symbol.map",{value:e,map:this._inner.map},t,r)}}return{value:e,errors:"symbol"==typeof e?null:this.createError("symbol.base",{value:e},t,r)}}map(e){e&&!e[Symbol.iterator]&&"object"==typeof e&&(e=Object.entries(e)),Hoek.assert(e&&e[Symbol.iterator],"Iterable must be an iterable or object");const t=this.clone(),r=[];for(const s of e){Hoek.assert(s&&s[Symbol.iterator],"Entry must be an iterable");const[e,n]=s;Hoek.assert("object"!=typeof e&&"function"!=typeof e&&"symbol"!=typeof e,"Key must not be an object, function, or Symbol"),Hoek.assert("symbol"==typeof n,"Value must be a Symbol"),t._inner.map.set(e,n),r.push(n)}return t.valid(...r)}describe(){const e=super.describe();return e.map=new Map(this._inner.map),e}},module.exports=new internals.Symbol;